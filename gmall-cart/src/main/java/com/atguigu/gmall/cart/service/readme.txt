添加购物车的流程：
两种情况：
一、添加购物车已经有的商品，那么修改数量同步到redis缓存和mysql数据库中
二、添加购物车中没有的商品，通过参数skuId从属性表里面查到对应的数据，同步到redis缓存和mysql数据库
    1、从拦截器中获取userKey
    2、通过userKey查询redis缓存，如果缓存中可以查到，那么将mysql的商品数量+1，且缓存数量也+1
    3、如果不能从缓存中查到，那么就通过skuId,从属性单元中获取对应信息，设置到购物车对象中。
       同时更新到mysql数据库+redis缓存中

登录情况下
    添加购物车已经有的的商品
        那么可以直接从redis缓存中命中购物车商品，然后修改数量以userId作为唯一标识保存到Redis+mysql，更新MySQL是以异步的方式更新
    添加购物车没有的商品
        此时缓存中也没有。那么根据skuId查询对应的商品：然后以userId作为唯一标识保存到Redis+mysql
未登录情况下
     添加购物车已经有的的商品
        那么直接从redis缓存中命中购物车商品，然后修改数量以随机生成的userKey作为唯一标识保存到Redis+mysql，更新MySQL是以异步的方式更新
     添加购物车没有的商品
        此时缓存中也没有。那么根据skuId查询对应的商品：然后以以随机生成的userKey作为唯一标识保存到Redis+mysql




查询购物车的流程：
两种情况：
一、未登录状态下，通过userKey先从redis缓存中命中购物车信息，返回给前端
二、登录状态下，：1、将未登录的购物车商品和登录的购物车商品合并：
                        两种情况：1）未登录和登录的状态的商品一样，则登录状态商品数量增加:保存到redis缓存和mysql数据库。
                                 2）未登录和登录状态商品一样，则将未登录的userId改为用户的id：保存到redis和mysql数据库
                                 3）删除未登录购物车的商品信息

未登录状态下
    通过userKey直接从redis缓存命中购物车的信息，返回
登录状态下
    将未登录的购物车商品和登录的购物车商品合并
    1）未登录和登录的状态的商品一样，则登录状态商品数量增加:保存到redis缓存和mysql数据库。
    2）未登录和登录状态商品一样，则将未登录的userId改为用户的id：保存到redis和mysql数据库
    3）删除未登录状态的购物车商品信息

解决缓存一致性问题：
线程1删除缓存，然后去更新数据库
线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存
线程1根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除
如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值


异步：此模块异步保存购物车到mysql
springboot提供的声明式异步方案：
    springTask:
        配置类@EnableAsync  方法上：@Async